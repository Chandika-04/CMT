# Generated by Django 2.0.3 on 2018-06-15 18:31
import datetime
from django.core.management import BaseCommand

from django.utils import timezone
from core.models import TODAY_END, forever
from django.db import models
from users.models import User


class Command(BaseCommand):
    # Show this when the user types help
    help = "Clear duplicate or missing status for members"

    def handle(self, *args, **options):
        future = TODAY_END + timezone.timedelta(days=5 * 365)
        # Only have one status, and it is not current, need to fix
        users = (
            User.objects.all()
            .annotate(models.Count("status"))
            .order_by()
            .filter(status__count=1)
            .filter(status__end__lte=TODAY_END)
        )
        for user in users:
            user_status = user.status.get()
            user_status.end = forever()
            user_status.save()

        # Users with no current status
        users = User.objects.exclude(
            status__start__lte=TODAY_END, status__end__gte=TODAY_END
        )
        print(f"{users} with no current status")

        # Users with duplicate current statuss
        dup_status = (
            User.objects.filter(
                status__start__lte=TODAY_END,
                status__end__gte=future,  # Use future to avoid the suspend/away status that will end sooner
            )
            .annotate(models.Count("id"))
            .order_by()
            .filter(id__count__gt=1)
        )
        total = len(dup_status)
        print(f"{total} duplicate status")
        for count, user in enumerate(dup_status):
            current_status = None
            other_statuss = []
            current_statuss = user.status.filter(
                start__lte=TODAY_END, end__gte=TODAY_END
            ).values_list("status", flat=True)
            print(f"{count + 1}/{total} {user} Current duplicates: {current_statuss}")
            status_check = [
                "deceased",
                "expelled",
                "resigned",
                "alumni",
                "alumniCC",
                "alumnipend",
                "suspended",
                "depledge",
                "active",
                "away",  # Comes after active b/c generally away should end sooner than active
                "activepend",
                "activeCC",
            ]

            for status in status_check:
                if status in current_statuss:
                    current_status = list(
                        user.status.filter(
                            models.Q(status=status),
                            start__lte=TODAY_END,
                            end__gte=TODAY_END,
                        )
                    )
                    print(f"    This is the current status {current_status}")
                    other_statuss = list(
                        user.status.filter(
                            ~models.Q(status=status),
                            start__lte=TODAY_END,
                            end__gte=TODAY_END,
                        )
                    )
                    print(f"    This is the other status {other_statuss}")
                    if len(current_status) > 1:
                        # If there are multiple of the same current status delete the others
                        print(f"        Current status same status! {current_status}")
                        remaining_statuss = current_status[1:]
                        print(f"        Remaining status {remaining_statuss}")
                        for remaining_status in remaining_statuss:
                            print("        Deleting extras")
                            remaining_status.delete()
                    current_status = current_status[0]
                    break
            if current_status:
                current_status.end = forever()
                current_status.save()
                for other_status in other_statuss:
                    print(f"        Setting other status to end {current_status.start}")
                    other_status.end = current_status.start - datetime.timedelta(days=1)
                    other_status.save()
